## 클라이언트의 연결
1. 서버와의 연결
2. 각 클라이언트에게 청크를 전송하는 연결
3. 각 클라이언트에게 청크를 전송받는 연결

위와 같이 연결을 구현했을 때 한 클라이언트당 총 7개의 연결이 이루어집니다.

## 알고리즘 설명
...

## 클라이언트가 주고 받는 청크 형식
> A0000003 x0bx32x81...  
256kb의 청크 앞에 무슨 파일인지, 몇 번째 청크인지를 붙여서 보내 청크들을 병합할 때 순서가 꼬이지 않도록 했습니다.

## 클라이언트 함수
클라이언트의 함수에 대해 설명합니다.

### send_chunk()
큐에 담겨져 있는 청크를 전송합니다.

### append_chunk_to_queue(conn, type)
클라이언트들에게 보낼 청크들을 큐에 담습니다.

### receive_from_server()
서버에게 메세지를 받는 쓰레드입니다. 
1. `start`를 전송받는 경우  
큐에 각 클라이언트에게 보낼 데이터를 담습니다.  
2. `status`를 전송받는 경우  
현재까지의 진행도를 서버에게 전송합니다.  
3. `end`를 전송받는 경우  
서버와의 연결을 종료합니다.

### receive_from_client()
다른 클라이언트들에게 데이터를 수신하는 쓰레드입니다. 데이터를 수신하면 위에서 설명한 청크 형식대로 받은 데이터를 분리해 저장합니다. 그리고 만약 받은 청크가 같은 환경에 위치해있는(로컬 - 로컬, 서버 - 서버) 클라이언트에서 온 청크라면 다른 환경에 있는 클라이언트로 보냅니다.

### run_client_connection(port)
클라이언트와의 연결을 위해 socket을 만듭니다.

### connect_client(port)
클라이언트와 연결을 성립합니다.

### connect_server()
서버와 연결합니다.

### end_checker()
데이터를 모두 전송받았다는 것을 확인합니다. 만약 데이터를 모두 전송받았으면 청크를 병합합니다.


## 서버 함수
서버의 함수입니다.

### accept_clients(server)
클라이언트와 연결합니다. 만약 네개의 클라이언트가 접속되었다면 system_clock을 진행시키고 만약  클라이언트간의 전송이 완료되었다면 파일을 전송하는데 소요된 시간을 출력하고 연결을 종료합니다.

### client_thread(client_index, client)
클라이언트의 메세지를 받아옵니다. 만약 "status"의 데이터를 받았으면 진행도를 출력하고 "end"메세지를 받았으면 end_count를 1 증가시킵니다. end_count가 4가 되면 클라이언트들이 모두 파일 전송이 완료된 상태이므로 모든 연결을 종료합니다.
